{"version":3,"file":"RealNodeModulePath.js","sourceRoot":"","sources":["../src/RealNodeModulePath.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as nodeFs from 'fs';\nimport * as nodePath from 'path';\n\n/**\n * Arguments used to create a function that resolves symlinked node_modules in a path\n * @public\n */\nexport interface IRealNodeModulePathResolverOptions {\n  fs: Pick<typeof nodeFs, 'lstatSync' | 'readlinkSync'>;\n  path: Pick<typeof nodePath, 'isAbsolute' | 'normalize' | 'resolve' | 'sep'>;\n}\n\n/**\n * This class encapsulates a caching resolver for symlinks in node_modules directories.\n * It assumes that the only symlinks that exist in input paths are those that correspond to\n * npm packages.\n *\n * @remarks\n * In a repository with a symlinked node_modules installation, some symbolic links need to be mapped for\n * node module resolution to produce correct results. However, calling `fs.realpathSync.native` on every path,\n * as is commonly done by most resolvers, involves an enormous number of file system operations (for reference,\n * each invocation of `fs.realpathSync.native` involves a series of `fs.readlinkSync` calls, up to one for each\n * path segment in the input).\n *\n * @public\n */\nexport class RealNodeModulePathResolver {\n  /**\n   * Similar in function to `fs.realpathSync.native`, but assumes the only symlinks present are npm packages.\n   *\n   * @param input - A path to a file or directory, where the path separator is `${require('node:path').sep}`\n   * @returns The real path to the input, resolving the node_modules symlinks in the path\n   * @public\n   */\n  public readonly realNodeModulePath: (input: string) => string;\n\n  private readonly _cache: Map<string, string>;\n  private readonly _fs: IRealNodeModulePathResolverOptions['fs'];\n\n  public constructor(\n    options: IRealNodeModulePathResolverOptions = {\n      fs: nodeFs,\n      path: nodePath\n    }\n  ) {\n    const cache: Map<string, string> = (this._cache = new Map());\n    const { path, fs } = options;\n    const { sep: pathSeparator } = path;\n    this._fs = fs;\n\n    const nodeModulesToken: string = `${pathSeparator}node_modules${pathSeparator}`;\n\n    const tryReadLink: (link: string) => string | undefined = this._tryReadLink.bind(this);\n\n    function realNodeModulePathInternal(input: string): string {\n      // Find the last node_modules path segment\n      const nodeModulesIndex: number = input.lastIndexOf(nodeModulesToken);\n      if (nodeModulesIndex < 0) {\n        // No node_modules in path, so we assume it is already the real path\n        return input;\n      }\n\n      // First assume that the next path segment after node_modules is a symlink\n      let linkStart: number = nodeModulesIndex + nodeModulesToken.length - 1;\n      let linkEnd: number = input.indexOf(pathSeparator, linkStart + 1);\n      // If the path segment starts with a '@', then it is a scoped package\n      const isScoped: boolean = input.charAt(linkStart + 1) === '@';\n      if (isScoped) {\n        // For a scoped package, the scope is an ordinary directory, so we need to find the next path segment\n        if (linkEnd < 0) {\n          // Symlink missing, so see if anything before the last node_modules needs resolving,\n          // and preserve the rest of the path\n          return `${realNodeModulePathInternal(input.slice(0, nodeModulesIndex))}${input.slice(nodeModulesIndex)}`;\n        }\n\n        linkStart = linkEnd;\n        linkEnd = input.indexOf(pathSeparator, linkStart + 1);\n      }\n\n      // No trailing separator, so the link is the last path segment\n      if (linkEnd < 0) {\n        linkEnd = input.length;\n      }\n\n      const linkCandidate: string = input.slice(0, linkEnd);\n      // Check if the link is a symlink\n      const linkTarget: string | undefined = tryReadLink(linkCandidate);\n      if (linkTarget && path.isAbsolute(linkTarget)) {\n        // Absolute path, combine the link target with any remaining path segments\n        // Cache the resolution to avoid the readlink call in subsequent calls\n        cache.set(linkCandidate, linkTarget);\n        cache.set(linkTarget, linkTarget);\n        return `${linkTarget}${input.slice(linkEnd)}`;\n      }\n\n      // Relative path or does not exist\n      // Either way, the path before the last node_modules could itself be in a node_modules folder\n      // So resolve the base path to find out what paths are relative to\n      const realpathBeforeNodeModules: string = realNodeModulePathInternal(input.slice(0, nodeModulesIndex));\n      if (linkTarget) {\n        // Relative path in symbolic link. Should be resolved relative to real path of base path.\n        const resolvedTarget: string = path.resolve(\n          `${realpathBeforeNodeModules}${input.slice(nodeModulesIndex, linkStart)}`,\n          linkTarget\n        );\n        // Cache the result of the combined resolution to avoid the readlink call in subsequent calls\n        cache.set(linkCandidate, resolvedTarget);\n        cache.set(resolvedTarget, resolvedTarget);\n        return `${resolvedTarget}${input.slice(linkEnd)}`;\n      }\n\n      // No symlink, so just return the real path before the last node_modules combined with the\n      // subsequent path segments\n      return `${realpathBeforeNodeModules}${input.slice(nodeModulesIndex)}`;\n    }\n\n    this.realNodeModulePath = (input: string) => {\n      return realNodeModulePathInternal(path.normalize(input));\n    };\n  }\n\n  /**\n   * Clears the cache of resolved symlinks.\n   * @public\n   */\n  public clearCache(): void {\n    this._cache.clear();\n  }\n\n  /**\n   * Tries to read a symbolic link at the specified path.\n   * If the input is not a symbolic link, returns undefined.\n   * @param link - The link to try to read\n   * @returns The target of the symbolic link, or undefined if the input is not a symbolic link\n   */\n  private _tryReadLink(link: string): string | undefined {\n    const cached: string | undefined = this._cache.get(link);\n    if (cached) {\n      return cached;\n    }\n\n    // On Windows, calling `readlink` on a directory throws an EUNKOWN, not EINVAL, so just pay the cost\n    // of an lstat call.\n    const stat: nodeFs.Stats | undefined = this._fs.lstatSync(link);\n    if (stat.isSymbolicLink()) {\n      return this._fs.readlinkSync(link, 'utf8');\n    }\n  }\n}\n"]}